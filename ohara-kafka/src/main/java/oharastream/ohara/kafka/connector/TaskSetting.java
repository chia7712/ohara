/*
 * Copyright 2019 is-land
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package oharastream.ohara.kafka.connector;

import static oharastream.ohara.common.util.CommonUtils.toDuration;

import java.time.Duration;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import oharastream.ohara.common.annotations.VisibleForTesting;
import oharastream.ohara.common.data.Column;
import oharastream.ohara.common.setting.*;
import oharastream.ohara.common.util.CommonUtils;
import oharastream.ohara.kafka.connector.json.ConnectorDefUtils;
import oharastream.ohara.kafka.connector.json.StringList;

/** this class carries all required settings for row connectors. */
public class TaskSetting {
  /**
   * create a TaskSetting based on raw input. This method is used by task. It doesn't need to fill
   * the default value since the raw input is generated by connector itself.
   *
   * @param options raw input
   * @return TaskSetting
   */
  @VisibleForTesting
  public static TaskSetting of(Map<String, String> options) {
    return new TaskSetting(options);
  }

  private final Map<String, String> raw;

  private TaskSetting(Map<String, String> raw) {
    this.raw = Collections.unmodifiableMap(Objects.requireNonNull(raw));
    raw.forEach(
        (k, v) -> {
          CommonUtils.requireNonEmpty(k, () -> "k:" + k + ", v:" + v);
          CommonUtils.requireNonEmpty(v, () -> "k:" + k + ", v:" + v);
        });
  }

  /**
   * take object key value according to mapped key.
   *
   * @param key key
   * @throws NoSuchElementException if no existent value for input key
   * @return value
   */
  public ObjectKey objectKey(String key) {
    if (raw.containsKey(key)) return ObjectKey.toObjectKey(raw.get(key));
    else throw new NoSuchElementException(key + " doesn't exist");
  }

  /**
   * take string value according to mapped key.
   *
   * @param key key
   * @throws NoSuchElementException if no existent value for input key
   * @return value
   */
  public String stringValue(String key) {
    if (raw.containsKey(key)) return raw.get(key);
    else throw new NoSuchElementException(key + " doesn't exist");
  }

  /**
   * take string value according to mapped key.
   *
   * @param key key
   * @throws NoSuchElementException if no existent value for input key
   * @return value
   */
  public Optional<String> stringOption(String key) {
    return Optional.ofNullable(raw.get(key));
  }

  /**
   * take long value according to mapped key.
   *
   * @param key key
   * @throws NoSuchElementException if no existent value for input key
   * @throws NumberFormatException If the string cannot be parsed as a {@code long}.
   * @return value
   */
  public long longValue(String key) {
    return Long.parseLong(stringValue(key));
  }

  /**
   * take long value according to mapped key.
   *
   * @param key key
   * @throws NoSuchElementException if no existent value for input key
   * @throws NumberFormatException If the string cannot be parsed as a {@code long}.
   * @return value
   */
  public Optional<Long> longOption(String key) {
    return Optional.ofNullable(raw.get(key)).map(Long::valueOf);
  }

  /**
   * take int value according to mapped key.
   *
   * @param key key
   * @throws NoSuchElementException if no existent value for input key
   * @throws NumberFormatException If the string cannot be parsed as a {@code int}.
   * @return value
   */
  public int intValue(String key) {
    return Integer.parseInt(stringValue(key));
  }

  /**
   * take int value according to mapped key.
   *
   * @param key key
   * @throws NoSuchElementException if no existent value for input key
   * @throws NumberFormatException If the string cannot be parsed as a {@code int}.
   * @return value
   */
  public Optional<Integer> intOption(String key) {
    return Optional.ofNullable(raw.get(key)).map(Integer::valueOf);
  }

  /**
   * take short value according to mapped key.
   *
   * @param key key
   * @throws NoSuchElementException if no existent value for input key
   * @throws NumberFormatException If the string cannot be parsed as a {@code short}.
   * @return value
   */
  public short shortValue(String key) {
    return Short.parseShort(stringValue(key));
  }

  /**
   * take short value according to mapped key.
   *
   * @param key key
   * @throws NoSuchElementException if no existent value for input key
   * @throws NumberFormatException If the string cannot be parsed as a {@code short}.
   * @return value
   */
  public Optional<Short> shortOption(String key) {
    return Optional.ofNullable(raw.get(key)).map(Short::valueOf);
  }

  /**
   * take double value according to mapped key.
   *
   * @param key key
   * @throws NoSuchElementException if no existent value for input key
   * @throws NumberFormatException If the string cannot be parsed as a {@code double}.
   * @return value
   */
  public double doubleValue(String key) {
    return Double.parseDouble(stringValue(key));
  }

  /**
   * take double value according to mapped key.
   *
   * @param key key
   * @throws NoSuchElementException if no existent value for input key
   * @throws NumberFormatException If the string cannot be parsed as a {@code double}.
   * @return value
   */
  public Optional<Double> doubleOption(String key) {
    return Optional.ofNullable(raw.get(key)).map(Double::valueOf);
  }

  /**
   * take boolean value according to mapped key.
   *
   * @param key key
   * @throws NoSuchElementException if no existent value for input key
   * @throws IllegalArgumentException If the string cannot be parsed as a {@code boolean}.
   * @return value
   */
  public boolean booleanValue(String key) {
    return toBoolean(stringValue(key));
  }

  private static boolean toBoolean(String value) {
    // NOTED: Boolean.valueOF doesn't handle the non-boolean string, so we do it manually.
    if (value.equalsIgnoreCase("true")) return true;
    else if (value.equalsIgnoreCase("false")) return false;
    else throw new IllegalArgumentException("\"" + value + "\" is not boolean type");
  }

  /**
   * take boolean value according to mapped key.
   *
   * @param key key
   * @throws NoSuchElementException if no existent value for input key
   * @throws IllegalArgumentException If the string cannot be parsed as a {@code boolean}.
   * @return value
   */
  public Optional<Boolean> booleanOption(String key) {
    return Optional.ofNullable(raw.get(key)).map(TaskSetting::toBoolean);
  }

  /**
   * take strings value according to mapped key.
   *
   * @param key key
   * @throws NoSuchElementException if no existent value for input key
   * @return value
   */
  public List<String> stringList(String key) {
    return StringList.ofKafkaList(stringValue(key));
  }

  /**
   * take strings value according to mapped key.
   *
   * @param key key
   * @throws NoSuchElementException if no existent value for input key
   * @return value
   */
  public Optional<List<String>> stringListOption(String key) {
    return Optional.ofNullable(raw.get(key)).map(StringList::ofKafkaList);
  }

  /**
   * take table value according to mapped key.
   *
   * @param key key
   * @throws NoSuchElementException if no existent value for input key
   * @return value
   */
  public PropGroup propGroup(String key) {
    return PropGroup.ofJson(stringValue(key));
  }

  /**
   * take table value according to mapped key.
   *
   * @param key key
   * @throws NoSuchElementException if no existent value for input key
   * @return value
   */
  public Optional<PropGroup> propGroupOption(String key) {
    return Optional.ofNullable(raw.get(key)).map(PropGroup::ofJson);
  }

  /**
   * get a duration related to input key
   *
   * @param key key
   * @throws NoSuchElementException if no existent value for input key
   * @return duration value
   */
  public Duration duration(String key) {
    return toDuration(stringValue(key));
  }

  /**
   * get a duration related to input key
   *
   * @param key key
   * @return duration value
   */
  public Optional<Duration> durationOption(String key) {
    return Optional.ofNullable(raw.get(key)).map(CommonUtils::toDuration);
  }

  // ----------------------------------[helper methods]----------------------------------//
  public String name() {
    return stringValue(ConnectorDefUtils.CONNECTOR_NAME_DEFINITION.key());
  }

  /** @return topic keys associated to "topicKeys" */
  public Set<TopicKey> topicKeys() {
    return Set.copyOf(
        TopicKey.toTopicKeys(stringValue(ConnectorDefUtils.TOPIC_KEYS_DEFINITION.key())));
  }

  public List<Column> columns() {
    return propGroupOption(ConnectorDefUtils.COLUMNS_DEFINITION.key())
        .map(PropGroup::toColumns)
        .orElseGet(Collections::emptyList);
  }

  public ConnectorKey connectorKey() {
    return ConnectorKey.toConnectorKey(
        stringValue(ConnectorDefUtils.CONNECTOR_KEY_DEFINITION.key()));
  }

  /**
   * the check rule for this connector
   *
   * @return check rule
   */
  public SettingDef.CheckRule checkRule() {
    return stringOption(ConnectorDefUtils.CHECK_RULE_DEFINITION.key())
        .map(
            s -> {
              try {
                return SettingDef.CheckRule.valueOf(s.toUpperCase());
              } catch (Throwable e) {
                // unknown string is converted to none
                return SettingDef.CheckRule.NONE;
              }
            })
        .orElse(SettingDef.CheckRule.NONE);
  }

  @VisibleForTesting
  Map<String, String> raw() {
    return Collections.unmodifiableMap(raw);
  }

  /**
   * Clone this TaskSetting with new setting. The new setting overwrite the old value if the key
   * exists.
   *
   * @param newConfig new setting
   * @return new TaskSetting
   */
  public TaskSetting append(Map<String, String> newConfig) {
    Map<String, String> raw = new HashMap<>(this.raw);
    raw.putAll(newConfig);
    return TaskSetting.of(raw);
  }
}
